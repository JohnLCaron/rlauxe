package org.cryptobiotic.rlauxe

import kotlin.random.Random
import kotlin.test.Test

data class BravoResult(val eta0: Double,
                       val trueMean: Double,
                       val sampleCount: Double,
                       val sampleMean: Double,
                       val failPct : Double,
                       val hist: Histogram? = null,
                       val status: Histogram? = null,
) {
    override fun toString() = buildString {
        appendLine("BravoResult(eta0=$eta0, trueMean=$trueMean, sampleCount=$sampleCount, sampleMean=$sampleMean, failPct=$failPct")
        if (hist != null) appendLine("  hist=${hist.toStringBinned()}")
        if (status != null) appendLine("  status=${status.toString(listOf("RejectNull","SampleSum","LimitReached"))}")
    }
}

// Test Alpha running BRAVO. Compare against UnifiedEvaluation tables (with replacement only)
// A Unified Evaluation of Two-Candidate Ballot-Polling Election Auditing Methods	Huang; 12 May 2021
class TestBravo  {

    @Test
    fun testBravo() {
        val N = 20_000
        val m = 100
        runBravo(N, m, .55, .55, withoutReplacement = true)
    }

    @Test
    fun testAgainstUnifiedWithReplacement() {
        val etas = listOf(.7, .55, .51)
        val trueMeans = listOf(.52, .55, .60, .64, .70)

        val results = mutableListOf<BravoResult> ()
        etas.forEach { results.addAll(runBravoRepeat(it, trueMeans, false)) }

        show("sampleCount", etas, trueMeans, results)
        // show("sampleMean", etas, trueMeans, results)
        show("failAvg", etas, trueMeans, results)
    }

    @Test
    fun testAgainstUnifiedWithoutReplacement() {
        val etas = listOf(.7, .55, .51)
        val trueMeans = listOf(.52, .55, .60, .64, .70)
        println("testAgainstUnifiedWithoutReplacement")

        val results = mutableListOf<BravoResult> ()
        etas.forEach { results.addAll(runBravoRepeat(it, trueMeans, true)) }

        show("sampleCount", etas, trueMeans, results)
        // show("sampleMean", etas, trueMeans, results)
        show("failPct", etas, trueMeans, results)
    }

    fun runBravoRepeat(eta0: Double, trueMeans: List<Double>, withoutReplacement: Boolean ): List<BravoResult> {
        val N = 20_000
        val m = 2000
        val nrepeat = 1000
        val results = mutableListOf<BravoResult>()
        trueMeans.forEach {
            results.add(runBravo(N, m, eta0, it, withoutReplacement, nrepeat))
        }
        return results
    }

    fun runBravo(N : Int, m: Int, eta0 : Double, trueMean: Double, withoutReplacement: Boolean, nrepeat:Int = 1): BravoResult  {
        //println("runBravo N=$N eta0=$eta0 trueMean=$trueMean repeat=$nrepeat")
        val estimFn = FixedMean(eta0)

        val alpha = AlphaAlgorithm(estimFn=estimFn, N=N, upperBound=1.0, withoutReplacement=withoutReplacement)
        val sampler = GenerateAssorterValue(trueMean)

        var sampleCountSum = 0
        var sampleMeanSum = 0.0
        var fail = 0
        var nsuccess = 0
        repeat(nrepeat) {
            val testH0Result = alpha.testH0(m) { sampler.sample() }
            sampleMeanSum += testH0Result.sampleMean
            if (testH0Result.status == TestH0Status.LimitReached) {
                fail++
            } else {
                nsuccess++
                sampleCountSum += testH0Result.sampleCount
            }
        }
        val sampleNumberAvg = sampleCountSum.toDouble() / nsuccess
        val failAvg = fail.toDouble() / nrepeat
        val sampleMeanAvg = sampleMeanSum / nrepeat
        return BravoResult(eta0, trueMean, sampleNumberAvg, sampleMeanAvg, failAvg)
    }


    @Test
    fun testWithSampleMean() { // Seems stupid not to use the sample mean for et0:
        val randomMeans = listOf(.505, .51, .52, .53, .55, .60)
        val randomMeans1 = listOf(.505)
        val N = 20_000
        val m = 4000
        val nrepeat = 1000

        randomMeans.forEach { ratio ->
            val sampler = SampleFromArrayWithReplacement(N, ratio)
            val result = runBravo(sampler, m, ratio, nrepeat, false)
            val voteDiff = N * (result.eta0 - ratio)
            println(" testWithSampleMean ratio=${"%5.4f".format(ratio)} "+
                    "eta0=${"%5.4f".format(result.eta0)} " +
                    "voteDiff=${"%4d".format(voteDiff.toInt())} " +
                    "sampleCount=${df.format(result.sampleCount.toInt())} " +
                    // "sampleMean=${"%5.4f".format(result.sampleMean)} " +
                    "cumulhist=${result.hist!!.cumul()}" +
                    // "fail=${(result.failPct * nrepeat).toInt()} " +
                    "status=${result.status} "
            )
        }
    }

    // in this scenario, the ration that the sample was generated by is the "true mean", and the generated samples reflect errors.
    // the diff between the two must have some spread, eg normal dist ??
    fun runBravo(drawSample : SampleFn, m: Int, trueMean: Double, nrepeat:Int = 1, withoutReplacement: Boolean = true): BravoResult  {
        var sampleCountSum = 0
        var sampleMeanSum = 0.0
        var fail = 0
        var nsuccess = 0

        val eta0 = drawSample.sampleMean()
        val estimFn = FixedMean(eta0)
        val alpha = AlphaAlgorithm(
            estimFn = estimFn,
            N = drawSample.N(),
            upperBound = 1.0,
            withoutReplacement = withoutReplacement
        )
        val hist = Histogram(1000)
        val status = Histogram(1)

        repeat(nrepeat) {
            drawSample.reset()
            val testH0Result = alpha.testH0(m) { drawSample.sample() }
            status.add(testH0Result.status.ordinal)
            sampleMeanSum += testH0Result.sampleMean
            if (testH0Result.status == TestH0Status.LimitReached) {
                fail++
            } else {
                nsuccess++
                sampleCountSum += testH0Result.sampleCount
                hist.add(testH0Result.sampleCount)
            }
        }

        val sampleNumberAvg = sampleCountSum.toDouble() / nsuccess
        val failAvg = fail.toDouble() / nrepeat
        val sampleMeanAvg = sampleMeanSum / nrepeat
        return BravoResult(eta0, trueMean, sampleNumberAvg, sampleMeanAvg, failAvg, hist, status)
    }

}

val ff = "%5.2f"
val df = "%5d"

fun show(title: String, eta0s: List<Double>, trueMeans: List<Double>, results: List<BravoResult>) {
    println(title)

    val eta0Map = mutableMapOf<Double, MutableMap<Double, Double>>()
    results.forEach { result ->
        val mlist = eta0Map.getOrPut(result.eta0) { mutableMapOf() }
        mlist[result.trueMean] =  when (title) {
            "sampleCount" -> result.sampleCount
            "sampleMean" -> result.sampleMean
            else -> result.failPct
        }
    }

    print("   eta0       ")
    trueMeans.forEach{ print("${ff.format(it)}  ") }
    println()

    eta0s.forEach{ eta0 ->
        print("   ${ff.format(eta0)}       ")
        val meanMap = eta0Map[eta0]!!
        trueMeans.forEach{ trueMean ->
            val fld = meanMap[trueMean]!!
            val fldAsString = when (title) {
                "sampleCount" -> df.format(fld.toInt())
                "sampleMean" -> ff.format(fld)
                else -> ff.format(fld)
            }
            print("$fldAsString  ")
        }
        println()
    }
}

// – Set η0
//    For polling audits, η0 could be the reported mean value of the assorter.
//	    For instance, for the assertion corresponding to checking whether w got more votes than ℓ,
//	      η0 = (Nw + Nc /2)/N , where Nw is the number of votes reported for w , Nℓ is the
//	   number of votes reported for ℓ, and Nc = N − Nw − Nℓ is the number of ballot cards
//	   reported to have a vote for some other candidate or no valid vote in the contest.
//    For comparison audits, η0 can be based on assumed or historical rates of overstatement errors.
//
// – Define the function to update η based on the sample,
//	  e.g, η(i, X i−1 ) = ((d * η0 + S)/(d + i − 1) ∨ (eps(i) + µi )) ∧ u,    (2.5.2, eq 14, "truncated shrinkage")
//	    where S = Sum i−1 k=1 (Xk) is the sample sum of the first i − 1 draws
//	    and eps(i) = c/ sqrt(d + i − 1)
//	 set any free parameters in the function (e.g., d and c in this example). The only requirement is that
//	  η(i, X i−1 ) ∈ (µi , u), where µi := E(Xi |X i−1 ) is computed under the null.

// ηi = η0 := Nw /(Nw + Nℓ ), where Nw is the number of votes reported for candidate w and
// Nℓ is the number of votes reported for candidate ℓ: η is not updated as data are collected
class FixedMean(val eta0: Double): EstimFn {
    override fun eta(prevSamples: List<Double>): Double {
        return eta0
    }
}

class GenerateAssorterValue(val ratio: Double) {
    fun sample() : Double {
        val r = Random.nextDouble(1.0)
        return if (r < ratio) 1.0 else 0.0
    }
}

fun generateSample(N: Int, ratio: Double) : DoubleArray {
    return DoubleArray(N) {
        val r = Random.nextDouble(1.0)
        if (r < ratio) 1.0 else 0.0
    }
}

class SampleFromArrayWithReplacement(val N: Int, ratio: Double): SampleFn {
    val samples = generateSample(N, ratio)
    override fun sample(): Double {
        val idx = Random.nextInt(N) // withoutReplacement
        return samples[idx]
    }
    override fun reset() {
       // noop
    }
    override fun sampleMean() = samples.average()
    override fun N() = N
}