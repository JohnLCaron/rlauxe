package org.cryptobiotic.rlauxe.core

import kotlin.math.max
import kotlin.test.Test

val showDetail = false
class TestAlphaMart {

    @Test
    fun testWithSampleMean() { // use the sample mean for eta0:
        val randomMeans = listOf(.505, .51, .52, .53, .55, .60)
        val randomMeans1 = listOf(.55)
        val N = 10_000
        val m = 10_000
        val nrepeat = 10

        randomMeans.forEach { ratio ->
            val sampler = SampleFromArrayWithoutReplacement(generateSample(N, ratio))
            val result = runAlphaMart(sampler, m, genRatio=ratio, nrepeat = nrepeat)
            val voteDiff = N * (result.eta0 - ratio)
            println(
                " testWithSampleMean ratio=${"%5.4f".format(ratio)} " +
                        "eta0=${"%5.4f".format(result.eta0)} " +
                        "voteDiff=${"%4d".format(voteDiff.toInt())} " +
                        "sampleCount=${df.format(result.sampleCountAvg())} " +
                        // "sampleMean=${"%5.4f".format(result.sampleMean)} " +
                        "cumulhist=${result.hist!!.cumul()}" +
                        // "fail=${(result.failPct * nrepeat).toInt()} " +
                        "status=${result.status} "
            )
        }
    }
}

// in this scenario, the ratio that the sample was generated by is the "genRatio", and the generated samples reflect errors.
fun runAlphaMart(
    drawSample: SampleFn,
    maxSamples: Int,
    d: Int = 500,
    f: Double = 0.0,
    genRatio: Double,
    eta0: Double = drawSample.popMean(),
    withoutReplacement: Boolean = true,
    nrepeat: Int = 1,
): RepeatedResult {
    val N = drawSample.N()
    val t = 0.5
    val upperBound = 1.0
    val minsd = 1.0e-6
    val c = max(eps, ((eta0 - t) / 2))

    // class TruncShrinkage(val N: Int, val u: Double, val t: Double, val minsd : Double, val d: Int, val eta0: Double,
    //                     val f: Double, val c: Double, val eps: Double): EstimFn {
    val estimFn = TruncShrinkage(N, true, upperBound = upperBound, minsd = minsd, d = d, eta0 = eta0, f = f, c = c)

    val alpha = AlphaMart(
        estimFn = estimFn,
        N = N,
        upperBound = upperBound,
        withoutReplacement = withoutReplacement
    )

    var sampleMeanSum = 0.0
    var fail = 0
    var nsuccess = 0
    val hist = Histogram(1000) // bins of 1000
    val status = Histogram(1) // ordinal value of
    val welford = Welford()

    repeat(nrepeat) {
        drawSample.reset()
        val testH0Result = alpha.testH0(maxSamples, terminateOnNullReject=true) { drawSample.sample() }
        status.add(testH0Result.status.ordinal)
        sampleMeanSum += testH0Result.sampleMean
        if (testH0Result.status == TestH0Status.LimitReached) {
            fail++
            welford.update(N.toDouble())
            hist.add(N)
        } else {
            nsuccess++
            welford.update(testH0Result.sampleCount.toDouble())
            hist.add(testH0Result.sampleCount)
        }
        if (showDetail) println(" $it $testH0Result")
    }

    val failAvg = fail.toDouble() / nrepeat
    val sampleMeanAvg = sampleMeanSum / nrepeat
    // val eta0: Double,
    //                          val trueMean: Double,
    //                          val reps: Int,
    //                          val popMean: Double,
    //                          val sampleCountAvg: Double,
    //                          val failPct : Double,
    //                          val hist: Histogram? = null,
    //                          val status
    return RepeatedResult(eta0=eta0, genRatio, nrepeat, sampleMean=sampleMeanAvg, welford, failAvg, hist, status)
}