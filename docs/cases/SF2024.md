# SanFrancisco County 2024

* 1,603,908 cvrs
* 53 contests, 11 IRV
* 4224 pools with 216286 cards (13.5%), using SHANGRLA grouping.
* Many pools have only a few cards.

````
The election produced 1,603,908 CVRs, of which 216,286 were for cards
cast in 4,223 precinct batches and 1,387,622 CVRs were for vote-by-mail (VBM) cards.
````

Input is in _CVR_Export_20241202143051.zip_. This contains the Dominion CVR_Export JSON files, as well as the
Contest Manifest, Candidate Manifest, and other manifests. We also have the San Francisco County _summary.xml_ file from
their website for corroboration. The summary.xml ncards match the CVRS exactly, so there are no phantoms.

**CreateSfElection/CreateSfElectionNoStyles**: We read the CVR_Export files
and write equivilent csv files in our own "AuditableCard" format to a temporary "cvrExport.csv" file.
We make the contests from the information in ContestManifest and CandidateManifest files,
and tabulate the votes from the cvrs. If its an IRV contest, we use the raire-java library to create the Raire assertions.
We write the auditConfig.json (which contains the prn seed) and contests.json files to the audit directory.

**createSortedCards**: Using the prn seed, we assign prns to all cvrs and rewrite the cvrs to sortedCards.csv (optionally zipped), using an out-of-memory
sorting algorithm.

The CVRs are in two groups, "mail-in" and "in-person".

**CreateSfElection(isClca = false) One Audit, hasStyle:** assumes we can match all CVRs to physical ballots,
but the in-person (precinct) votes must be redacted and not available to be matched against the mvrs.
We can use OneAudit by putting the in-person cvrs into pools by precinct, since we can
then calculate the ContestTabulation and assortMean for each pool. For IRV, we can calculate the VoteConsolidator for each pool.
This allows us to calculate the RaireAssertions and assortMean for each pool.
So we can run a real IRV, at the cost of increased sample sizes to use OneAudit instead of CLCA.
In this case we use Card Style Data to do style sampling, which is equivilent to assuming we can match the CRV to the MRV,
but the in-person crv vote counts have been redacted for privacy reasons.

**CreateSfElection(isClca = true) CLCA, hasStyle:** assumes we can match all CVRs to physical ballots, so we can do a regular CLCA.
This allows us to compare the cost of OneAudit vs CLCA.

**CreateSfElectionPoolStyle(isPolling = false)_ One Audit, noStyle** assumes we cannot match precinct CVRs to physical ballots,
so uses OneAudit, and assumes that we dont know which cards have which contests for the pooled data. Instead it uses Philip's approach of
adding contest undervotes to all the cards in the pool (so that all cards have all the contests in the pool), and increasing the contest upper limit (Nc).
Consistent sampling is still used, but with increased undervotes in the pool ballots.

**CreateSfElectionPoolStyle(isPolling = true) One Audit, noStyle:** assumes we cannot match any CVRs to physical ballots,
so uses Polling. It is assumed that for each precinct, the set of possible contests for that precinct is known.
When creating the CardManifest, for each precinct, every cvr gets that list of contests on it. Then all the cards are read and for
each contest, the total number of ballots that may contain the contest is tabulated. This is Nb for that contest.
Consistent sampling can still be used, but the estimated ballots needed for each contest are scaled by Nb/Nc >= 1.