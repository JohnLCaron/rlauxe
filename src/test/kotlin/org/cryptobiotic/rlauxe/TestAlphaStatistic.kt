package org.cryptobiotic.rlauxe

import kotlin.math.max
import kotlin.math.min
import kotlin.math.sqrt
import kotlin.test.Test

class TestAlphaStatistic  {

    @Test
    fun testWithSampleMean() { // Seems stupid not to use the sample mean for eta0:
        val randomMeans = listOf(.505, .51, .52, .53, .55, .60)
        val randomMeans1 = listOf(.55)
        val N = 10_000
        val m = 10_000
        val nrepeat = 10

        randomMeans.forEach { ratio ->
            val sampler = SampleFromArrayWithoutReplacement(generateSample(N, ratio))
            val result = runAlphaGen(sampler, m, ratio, nrepeat, true)
            val voteDiff = N * (result.eta0 - ratio)
            println(" testWithSampleMean ratio=${"%5.4f".format(ratio)} "+
                    "eta0=${"%5.4f".format(result.eta0)} " +
                    "voteDiff=${"%4d".format(voteDiff.toInt())} " +
                    "sampleCount=${df.format(result.sampleCount.toInt())} " +
                    // "sampleMean=${"%5.4f".format(result.sampleMean)} " +
                    "cumulhist=${result.hist!!.cumul()}" +
                    // "fail=${(result.failPct * nrepeat).toInt()} " +
                    "status=${result.status} "
            )
        }
    }

    // in this scenario, the ration that the sample was generated by is the "true mean", and the generated samples reflect errors.
    // the diff between the two must have some spread, eg normal dist ??
    fun runAlphaGen(drawSample : SampleFn,
                    m: Int, trueMean: Double, nrepeat:Int = 1, withoutReplacement: Boolean = true): BravoResult  {

        val d = 1000
        val f = 0.0
        val t = 0.5
        val upperBound = 1.0
        val eps = 0.0001  // Generic small value
        val minsd = 1.0e-6
        val eta0 = drawSample.sampleMean()
        val c = (eta0 - t) / 2

        // class TruncShrinkage(val N: Int, val u: Double, val t: Double, val minsd : Double, val d: Int, val eta0: Double,
        //                     val f: Double, val c: Double, val eps: Double): EstimFn {
        val estimFn = TruncShrinkage(drawSample.N(), upperBound, t, minsd=minsd, d = d, eta0=eta0, f=f, c=c, eps=eps)

        val alpha = AlphaStatistic(
            estimFn = estimFn,
            N = drawSample.N(),
            upperBound = upperBound,
            withoutReplacement = withoutReplacement
        )

        var sampleCountSum = 0
        var sampleMeanSum = 0.0
        var fail = 0
        var nsuccess = 0
        val hist = Histogram(1000)
        val status = Histogram(1)

        repeat(nrepeat) {
            drawSample.reset()
            val testH0Result = alpha.testH0(m) { drawSample.sample() }
            status.add(testH0Result.status.ordinal)
            sampleMeanSum += testH0Result.sampleMean
            if (testH0Result.status == TestH0Status.LimitReached) {
                fail++
            } else {
                nsuccess++
                sampleCountSum += testH0Result.sampleCount
                hist.add(testH0Result.sampleCount)
            }
        }

        val sampleNumberAvg = sampleCountSum.toDouble() / nsuccess
        val failAvg = fail.toDouble() / nrepeat
        val sampleMeanAvg = sampleMeanSum / nrepeat
        return BravoResult(eta0, trueMean, sampleNumberAvg, sampleMeanAvg, failAvg, hist, status)
    }

}

class TruncShrinkage(val N: Int, val u: Double, val t: Double, val minsd : Double, val d: Int, val eta0: Double,
                     val f: Double, val c: Double, val eps: Double): EstimFn {
    val welford = Welford()

    override fun eta(prevSamples: List<Double>): Double {
        //if (prevSamples.size == 0) {
        //    return eta0
        // }
        val lastj = prevSamples.size

        val sampleSum = if (prevSamples.size == 0) 0.0 else {
            welford.update(prevSamples.last())
            prevSamples.subList(0, lastj - 1).sum() // LOOK only taking n-1
        }

        val (_, variance, _) = welford.result() // all we want is the variance ??
        val stdev = Math.sqrt(variance)
        val sdj3 = if (lastj < 2) 1.0 else max(stdev, minsd)

        val mean2 = mean2(N, t, prevSamples)

        // (2.5.2, eq 14, "truncated shrinkage")
        val weighted = ((d * eta0 + sampleSum) / (d + lastj - 1) + u * f / sdj3) / (1 + f / sdj3)

        // Choosing epsi . To allow the estimated winner’s share ηi to approach √ µi as the sample grows
        // (if the sample mean approaches µi or less), we shall take epsi := c/ sqrt(d + i − 1) for a nonnegative constant c,
        // for instance c = (η0 − µ)/2.
        // The estimate ηi is thus the sample mean, shrunk towards η0 and truncated to the interval [µi + ǫi , 1), where ǫi → 0 as the sample size grows.
        val npmax = max( weighted, mean2 + c / sqrt((d + lastj - 1).toDouble()))  // 2.5.2 "choosing ǫi"
        val eta = min(u * (1 - eps), npmax)

        // println("   TruncShrinkage ${welford.count} sampleSum= $sampleSum eta=$eta")
        return eta
    }

    fun mean2(N: Int, t: Double, x: List<Double>): Double {
        if (x.size == 0) return .5
        val sum = x.subList(0, x.size-1).sum()
        val m1 = (N * t - sum)
        val m2 = (N - x.size + 1)
        val m3 = m1 / m2
        return m3
    }
}