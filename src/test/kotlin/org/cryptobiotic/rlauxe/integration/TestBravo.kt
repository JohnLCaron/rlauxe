package org.cryptobiotic.rlauxe.integration

import org.cryptobiotic.rlauxe.core.AlphaMart
import org.cryptobiotic.rlauxe.core.EstimFn
import org.cryptobiotic.rlauxe.core.SampleFn
import org.cryptobiotic.rlauxe.core.Samples
import org.cryptobiotic.rlauxe.core.Welford
import kotlin.random.Random
import kotlin.test.Test

// Test Alpha running BRAVO. Compare against UnifiedEvaluation tables (with replacement only)
// A Unified Evaluation of Two-Candidate Ballot-Polling Election Auditing Methods	Huang; 12 May 2021
class TestBravo  {

    @Test
    fun testBravo() {
        val N = 20_000
        val m = 100
        runBravo(N, m, .55, .55, withoutReplacement = true)
    }

    @Test
    fun testAgainstUnifiedWithReplacement() {
        val etas = listOf(.7, .55, .51)
        val trueMeans = listOf(.52, .55, .60, .64, .70)

        val results = mutableListOf<AlphaMartRepeatedResult> ()
        etas.forEach { results.addAll(runBravoRepeat(it, trueMeans, false)) }

        show("sampleCountAvg", etas, trueMeans, results)
        // show("sampleMean", etas, trueMeans, results)
        show("failAvg", etas, trueMeans, results)
    }

    @Test
    fun testAgainstUnifiedWithoutReplacement() {
        val etas = listOf(.7, .55, .51)
        val trueMeans = listOf(.52, .55, .60, .64, .70)
        println("testAgainstUnifiedWithoutReplacement")

        val results = mutableListOf<AlphaMartRepeatedResult> ()
        etas.forEach { results.addAll(runBravoRepeat(it, trueMeans, true)) }

        show("sampleCountAvg", etas, trueMeans, results)
        // show("sampleMean", etas, trueMeans, results)
        show("failPct", etas, trueMeans, results)
    }

    fun runBravoRepeat(eta0: Double, trueMeans: List<Double>, withoutReplacement: Boolean ): List<AlphaMartRepeatedResult> {
        val N = 20_000
        val m = 2000
        val nrepeat = 100
        val results = mutableListOf<AlphaMartRepeatedResult>()
        trueMeans.forEach {
            results.add(runBravo(N, m, eta0, it, withoutReplacement, nrepeat))
        }
        return results
    }

    fun runBravo(N : Int, m: Int, eta0 : Double, trueMean: Double, withoutReplacement: Boolean, nrepeat:Int = 1): AlphaMartRepeatedResult  {
        //println("runBravo N=$N eta0=$eta0 trueMean=$trueMean repeat=$nrepeat")
        val estimFn = FixedMean(eta0)
        val alpha = AlphaMart(estimFn = estimFn, N = N, upperBound = 1.0, withoutReplacement = withoutReplacement)
        val sampler = GenerateAssorterValue(trueMean)

        val welford = Welford()
        var sampleMeanSum = 0.0
        var fail = 0
        var nsuccess = 0
        repeat(nrepeat) {
            val testH0Result = alpha.testH0(m, true) { sampler.sample() }
            sampleMeanSum += testH0Result.sampleMean
            if (testH0Result.status.fail) {
                fail++
            } else {
                nsuccess++
                welford.update(testH0Result.sampleCount.toDouble())
            }
        }
        val failAvg = fail.toDouble() / nrepeat
        val sampleMeanAvg = sampleMeanSum / nrepeat
        return AlphaMartRepeatedResult(eta0=eta0, N=N, theta=trueMean, sampleMeanAvg, nrepeat, welford, failAvg)
    }


    @Test
    fun testWithSampleMean() { // Seems stupid not to use the sample mean for et0:
        val randomMeans = listOf(.505, .51, .52, .53, .55, .60)
        val N = 20_000
        val m = 4000
        val nrepeat = 100

        randomMeans.forEach { ratio ->
            val sampler = SampleFromArrayWithReplacement(N, ratio)
            val result = runBravo(sampler, m, ratio, nrepeat, false)
            val voteDiff = N * (result.eta0 - ratio)
            println(" testWithSampleMean ratio=${"%5.4f".format(ratio)} "+
                    "eta0=${"%5.4f".format(result.eta0)} " +
                    "voteDiff=${"%4d".format(voteDiff.toInt())} " +
                    "sampleCount=${df.format(result.sampleCountAvg())} " +
                    // "sampleMean=${"%5.4f".format(result.sampleMean)} " +
                    "nrepeat=${result.hist!!.cumulPct(nrepeat)}" +
                    // "fail=${(result.failPct * nrepeat).toInt()} " +
                    "status=${result.status} "
            )
        }
    }

    // in this scenario, the ration that the sample was generated by is the "true mean", and the generated samples reflect errors.
    // the diff between the two must have some spread, eg normal dist ??
    fun runBravo(drawSample : SampleFn, m: Int, trueMean: Double, nrepeat:Int = 1, withoutReplacement: Boolean = true): AlphaMartRepeatedResult  {
        var sampleCountSum = 0
        var sampleMeanSum = 0.0
        var fail = 0
        var nsuccess = 0

        val N = drawSample.N()
        val eta0 = drawSample.truePopulationMean()
        val estimFn = FixedMean(eta0)
        val alpha = AlphaMart(
            estimFn = estimFn,
            N = N,
            upperBound = 1.0,
            withoutReplacement = withoutReplacement
        )
        val hist = Histogram(1000)
        val welford = Welford()

        repeat(nrepeat) {
            drawSample.reset()
            val testH0Result = alpha.testH0(m, true) { drawSample.sample() }
            sampleMeanSum += testH0Result.sampleMean
            if (testH0Result.status.fail) {
                fail++
            } else {
                nsuccess++
                welford.update(testH0Result.sampleCount.toDouble())
                hist.add(testH0Result.sampleCount)
            }
        }

        val failAvg = fail.toDouble() / nrepeat
        val sampleMeanAvg = sampleMeanSum / nrepeat
        return AlphaMartRepeatedResult(eta0, N=N, theta=trueMean, sampleMeanAvg, nrepeat, welford, failAvg, hist, null)
    }

}

val ff = "%5.2f"
val df = "%5d"

fun show(title: String, eta0s: List<Double>, trueMeans: List<Double>, results: List<AlphaMartRepeatedResult>) {
    println(title)

    val eta0Map = mutableMapOf<Double, MutableMap<Double, Double>>()
    results.forEach { result ->
        val mlist = eta0Map.getOrPut(result.eta0) { mutableMapOf() }
        mlist[result.theta] =  when (title) {
            "sampleCountAvg" -> result.sampleCountAvg().toDouble()
            "sampleMean" -> result.sampleMean
            else -> result.failPct
        }
    }

    print("   eta0       ")
    trueMeans.forEach{ print("${ff.format(it)}  ") }
    println()

    eta0s.forEach{ eta0 ->
        print("   ${ff.format(eta0)}       ")
        val meanMap = eta0Map[eta0]!!
        trueMeans.forEach{ trueMean ->
            val fld = meanMap[trueMean]!!
            val fldAsString = when (title) {
                "sampleCount" -> df.format(fld.toInt())
                "sampleMean" -> ff.format(fld)
                else -> ff.format(fld)
            }
            print("$fldAsString  ")
        }
        println()
    }
}

// – Set η0
//    For polling audits, η0 could be the reported mean value of the assorter.
//	    For instance, for the assertion corresponding to checking whether w got more votes than ℓ,
//	      η0 = (Nw + Nc /2)/N , where Nw is the number of votes reported for w , Nℓ is the
//	   number of votes reported for ℓ, and Nc = N − Nw − Nℓ is the number of ballot cards
//	   reported to have a vote for some other candidate or no valid vote in the contest.
//    For comparison audits, η0 can be based on assumed or historical rates of overstatement errors.
//
// – Define the function to update η based on the sample,
//	  e.g, η(i, X i−1 ) = ((d * η0 + S)/(d + i − 1) ∨ (eps(i) + µi )) ∧ u,    (2.5.2, eq 14, "truncated shrinkage")
//	    where S = Sum i−1 k=1 (Xk) is the sample sum of the first i − 1 draws
//	    and eps(i) = c/ sqrt(d + i − 1)
//	 set any free parameters in the function (e.g., d and c in this example). The only requirement is that
//	  η(i, X i−1 ) ∈ (µi , u), where µi := E(Xi |X i−1 ) is computed under the null.

// ηi = η0 := Nw /(Nw + Nℓ ), where Nw is the number of votes reported for candidate w and
// Nℓ is the number of votes reported for candidate ℓ: η is not updated as data are collected
class FixedMean(val eta0: Double): EstimFn {
    override fun eta(prevSamples: Samples): Double {
        return eta0
    }
}

// TODO
class FixedAlternativeMean(val N: Int, val eta0:Double): EstimFn {

    //         val m = DoubleArray(x.size) {
    //            val m1 = (N * t - Sp[it])
    //            val m2 = (N - j[it] + 1)
    //            val m3 = m1 / m2
    //            if (isFinite) (N * t - Sp[it]) / (N - j[it] + 1) else t
    //        }

    override fun eta(prevSamples: Samples): Double {
        val j = prevSamples.size() + 1
        val sampleSum = prevSamples.sum()
        val m1 = (N * eta0 - sampleSum)
        val m2 = (N - j + 1)
        val m3 = m1 / m2
        val result = (N * eta0 - sampleSum) / (N - j + 1)
        return result
    }

}

class GenerateAssorterValue(val ratio: Double) {
    fun sample() : Double {
        val r = Random.nextDouble(1.0)
        return if (r < ratio) 1.0 else 0.0
    }
}

// generate a sample thats approximately mean = theta
fun generateSample(N: Int, ratio: Double) : DoubleArray {
    return DoubleArray(N) {
        val r = Random.nextDouble(1.0)
        if (r < ratio) 1.0 else 0.0
    }
}

class SampleFromArrayWithReplacement(val N: Int, ratio: Double): SampleFn {
    val samples = generateSample(N, ratio)
    override fun sample(): Double {
        val idx = Random.nextInt(N) // withoutReplacement
        return samples[idx]
    }
    override fun reset() {
       // noop
    }
    override fun truePopulationMean() = samples.average()
    override fun truePopulationCount() = samples.sum()
    override fun N() = N
}