package org.cryptobiotic.rlauxe

import kotlin.test.Test

val showDetail = false
class TestAlphaMart {

    @Test
    fun testWithSampleMean() { // use the sample mean for eta0:
        val randomMeans = listOf(.505, .51, .52, .53, .55, .60)
        val randomMeans1 = listOf(.55)
        val N = 10_000
        val m = 10_000
        val nrepeat = 10

        randomMeans.forEach { ratio ->
            val sampler = SampleFromArrayWithoutReplacement(generateSample(N, ratio))
            val result = runAlphaMart(sampler, m, genRatio=ratio, nrepeat = nrepeat)
            val voteDiff = N * (result.eta0 - ratio)
            println(
                " testWithSampleMean ratio=${"%5.4f".format(ratio)} " +
                        "eta0=${"%5.4f".format(result.eta0)} " +
                        "voteDiff=${"%4d".format(voteDiff.toInt())} " +
                        "sampleCount=${df.format(result.sampleCount.toInt())} " +
                        // "sampleMean=${"%5.4f".format(result.sampleMean)} " +
                        "cumulhist=${result.hist!!.cumul()}" +
                        // "fail=${(result.failPct * nrepeat).toInt()} " +
                        "status=${result.status} "
            )
        }
    }
}

// in this scenario, the ratio that the sample was generated by is the "genRatio", and the generated samples reflect errors.
fun runAlphaMart(
    drawSample: SampleFn,
    maxSamples: Int,
    d: Int = 500,
    genRatio: Double,
    eta0: Double = drawSample.sampleMean(),
    withoutReplacement: Boolean = true,
    nrepeat: Int = 1,
): BravoResult {
    val N = drawSample.N()
    val f = 0.0
    val t = 0.5
    val upperBound = 1.0
    val eps = 0.0001  // Generic small value
    val minsd = 1.0e-6
    val c = (eta0 - t) / 2

    // class TruncShrinkage(val N: Int, val u: Double, val t: Double, val minsd : Double, val d: Int, val eta0: Double,
    //                     val f: Double, val c: Double, val eps: Double): EstimFn {
    val estimFn = TruncShrinkage(N, upperBound, minsd = minsd, d = d, eta0 = eta0, f = f, c = c)

    val alpha = AlphaMart(
        estimFn = estimFn,
        N = N,
        upperBound = upperBound,
        withoutReplacement = withoutReplacement
    )

    var sampleCountSum = 0
    var sampleMeanSum = 0.0
    var fail = 0
    var nsuccess = 0
    val hist = Histogram(1000) // bins of 1000
    val status = Histogram(1) // ordinal value of

    repeat(nrepeat) {
        drawSample.reset()
        val testH0Result = alpha.testH0(maxSamples, terminateOnNullReject=true) { drawSample.sample() }
        status.add(testH0Result.status.ordinal)
        sampleMeanSum += testH0Result.sampleMean
        if (testH0Result.status == TestH0Status.LimitReached) {
            fail++
        } else {
            nsuccess++
            sampleCountSum += testH0Result.sampleCount
            hist.add(testH0Result.sampleCount)
        }
        if (showDetail) println(" $it $testH0Result")
    }

    val sampleNumberAvg = sampleCountSum.toDouble() / nsuccess
    val failAvg = fail.toDouble() / nrepeat
    val sampleMeanAvg = sampleMeanSum / nrepeat
    return BravoResult(eta0, genRatio, sampleNumberAvg, sampleMeanAvg, failAvg, hist, status)
}